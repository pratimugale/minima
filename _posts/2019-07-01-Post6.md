---
layout: post
title: "Week6"
categories: GSoC
---

## Monday 01-07-2019

Why is PWM on PRU is beneficial? 
There is hardware PWM support available on the BBB
that can be accessed directly from Linux user space. However, sysfs is slow
at adjusting the duty cycle, and it is prone to the same type of nonpreemptive latency issues as regular GPIOs.
PWM has many applications, such as motor and lighting control, and the PRU can provide a very high frequency PWM.
As a second example, we can use PWM for precise control of servo/stepper motors.
I also plan to use PWM with PRU to output a sine wave signal, by rapidly changing the duty cycle of a high‚Äêfrequency switched digital output cyclically as a function of time. For this, we can use the C-program to use mathematical functions to generate sine values which can be written into the PRU SRAM/DRAM. The PRU ASSEMBLY PROGRAM will read these duty cycle values from the memory and produce the output on the reuired GPIO pin.

After spending the weekend reading different PRU projects and trying different PWM variations, I have come up with a good example that gives a pretty accurate result. To set the PWM frequency from 1MHz to 1 Hz, I will need 4 bytes maximum(actually 27 bits) to store the total PWM cycles. (For 1MHz, 200 PRU cycles ((100 iterations) are needed; so for 1Hz, 200,000,000 total (PRU) cycles will be needed). So, memory location 0x00010000 to 0x00010003 will store (ON cycles)/2) and 0x00010005 to 0x00010008 will store ((maximum cycles)/2).<br>

For doing this, I will have to modify the mem_read(), mem_write() functions to handling 4 bytes of data at a time. Though this is a slow process of transferring data, it is helpful for experimenting and one time data transfer. This, ideally needs to be done using RPMsg.

**One important thing that I realized today is that the instruction `LBBO &R1, R10, 0, 4` stores the byte-wise data BACKWARDS into the register R1** It took me a while to realize this after getting some very wierd results.(The frequency of PWM became extremely low). <br>
So, what happens is: Suppose<br>
(0x00010000) -> 0xA5 <br>
(0x00010001) -> 0x31 <br>
(0x00010002) -> 0x54 <br>
(0x00010003) -> 0xFF <br>
Now if we do `LDI R10, 0x00010000` and `LBBO &R1, R10, 0, 4`. LBBO will copy 4 bytes of data into R1.<br>
But the value of R1 will be -> FF5431A5 and **NOT** A53154FF. 

Findings I have made on the `pwm-assembly` example in my repo:
* Using the above caculation, the period of PWM will be 1s if <br>
  (0x00010000) -> 0x80 <br>
  (0x00010001) -> 0xF0 <br>
  (0x00010002) -> 0xFA <br>
  (0x00010003) -> 0x02 <br>
  (0x00010005) -> 0x00 <br>
  (0x00010006) -> 0xE1 <br>
  (0x00010007) -> 0xF5 <br>
  (0x00010008) -> 0x05 <br>
  i.e. For this example, the ON_Cycles input is 50,000,000 and Total_Cycles = 100,000,000<br>
  These values are calculated by the userspace program that takes `frequency` and `duty cycle` as input. <br>
  100,000,000 * 2 = 200,000,000 (2 instructions per on/off loop) <br>
  200,000,000 * 5ns per step = 2 * 10^8 * 5 * 10^-9 seconds = 1 second time period. <br> 

* Using the `single_step` mode for frequency 1MHz 
  * 50% Duty Cycle: ie input ON_Cycles = 50 iterations (actually 50 * 2 PRU Cycles) and Total_Cycles = 100 iterations (200 PRU Cycles)<br>
    The GPIO is **HIGH** for: **104 steps** <br>
    THE GPIO is **LOW**  for: **103 steps** <br>
    Therefore; output DC = (104/207) * 100 % <br>
    I am still trying to reduce the steps to 100 so that the output frequency is exactly 1MHz. But while doing so, any changes made to the assembly program add additional unwanted steps further disrupting the DC or frequency.
    GPIO output voltage: 3.23V <br>
    50% DC GPIO voltage: 1.61V <br>
  * 25% Duty Cycle: 
    The GPIO is **HIGH** for: **54 steps**<br>
    THE GPIO is **LOW**  for: **153 steps**<br>
    GPIO output voltage: 3.23V<br>
    25% DC GPIO voltage: 0.81V<br>
  
  Conclusion: Total Cycles are 7 more than required. Removing even one NOP instruction in `sample_start` somehow further reduces the output Duty Cycle. For now I think that these additional steps are due to looping overhead. <br>
  `maximum output frequency` can further be increased but at the expense of Duty Cycle accuracy. For 1Mhz frequency the DC is accurate to 2 decimal places.
  I do not have an oscilloscope at the moment so I need to go to college to check it. But for 1Hz, the GPIO is ON for exactly 60 times in one minute.
