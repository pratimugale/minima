---
layout: post
title: "RPMsg"
categories: GSoC
---

# RPMsg

RPMsg is quite tricky to get started with and takes a lot of time to learn as the Documentation is quite scattered. So I'll try to sum it all up in this post and try to explain everything I can.

remoteproc - A framework for controlling the lifecycle of secondary processors in an asymmetric multiprocessor system. Asymmetric multiprocessor system means NOT all of the processors are treated equally. So the system may allow only one CPU to handle operating system code and other for I/O operations. In the case of a BeagleBone Black, we have ARM Cortex which runs the OS and 2 real-time, deterministic PRUs performing I/O tasks. The ARM and the PRU subsystems are connected via the L3 interconnect. <br>
It takes the ARM around 40 cycles to access the shared memory over L3 interconnect.
The PRU does not support asynchronous interrupts. Asynchronous interrupts can introduce jitter in execution time and
generally reduce determinism. 

Remoteproc enables the use of the RPMsg framework for message sharing. A resource table is necessary for the ARM - PRU communication that RPMsg provides. Using remoteproc is as simple as probing the driver, copying the firmware, and then use the exposed sysfs entries to control execution.

Now, coming to RPMsg, it is a Linux framework designed to allow for message passing between the kernel and a remote processor. Kernel documentation available in /Documentation/rpmsg.txt. It ties in with existing remoteproc driver framework and provides fairly simple interface for passing messages between User Space and the PRU firmware.
RPMsg exposes the virtual device (PRU) to the ARM User Space. User Space applications use the /dev/rpmsg_pruX to pass messages to and from the PRU.

References: 
1. [https://github.com/OpenAMP/open-amp/wiki/RPMsg-Messaging-Protocol](https://github.com/OpenAMP/open-amp/wiki/RPMsg-Messaging-Protocol)
2. [https://www.kernel.org/doc/Documentation/rpmsg.txt](https://www.kernel.org/doc/Documentation/rpmsg.txt)
